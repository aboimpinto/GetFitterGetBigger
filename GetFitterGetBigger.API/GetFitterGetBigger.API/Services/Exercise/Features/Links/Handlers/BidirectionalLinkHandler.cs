using GetFitterGetBigger.API.Constants;
using GetFitterGetBigger.API.DTOs;
using GetFitterGetBigger.API.Models.Enums;
using GetFitterGetBigger.API.Models.SpecializedIds;
using GetFitterGetBigger.API.Services.Exercise.Features.Links.DataServices;
using GetFitterGetBigger.API.Services.Results;

namespace GetFitterGetBigger.API.Services.Exercise.Features.Links.Handlers;

/// <summary>
/// Handles bidirectional link creation and deletion for exercise links
/// </summary>
public class BidirectionalLinkHandler(
    IExerciseLinkQueryDataService queryDataService,
    IExerciseLinkCommandDataService commandDataService,
    ILogger<BidirectionalLinkHandler> logger)
{
    /// <summary>
    /// Creates bidirectional links between exercises
    /// </summary>
    public async Task<ServiceResult<ExerciseLinkDto>> CreateBidirectionalLinkAsync(
        ExerciseId sourceId,
        ExerciseId targetId,
        ExerciseLinkType linkType)
    {
        // Get the reverse link type based on the mapping rules
        var reverseLinkType = GetReverseExerciseLinkType(linkType);
        
        // Calculate display orders for both links
        var primaryDisplayOrder = await CalculateDisplayOrderAsync(sourceId, linkType);
        
        // Create the primary link DTO
        var primaryLinkDto = new ExerciseLinkDto
        {
            Id = string.Empty, // Will be generated by the database
            SourceExerciseId = sourceId.ToString(),
            TargetExerciseId = targetId.ToString(),
            LinkType = linkType.ToString(),
            DisplayOrder = primaryDisplayOrder,
            IsActive = true
        };
        
        // Create the reverse link DTO if needed
        ExerciseLinkDto? reverseLinkDto = null;
        if (reverseLinkType.HasValue)
        {
            var reverseDisplayOrder = await CalculateDisplayOrderAsync(targetId, reverseLinkType.Value);
            reverseLinkDto = new ExerciseLinkDto
            {
                Id = string.Empty, // Will be generated by the database
                SourceExerciseId = targetId.ToString(),
                TargetExerciseId = sourceId.ToString(),
                LinkType = reverseLinkType.Value.ToString(),
                DisplayOrder = reverseDisplayOrder,
                IsActive = true
            };
        }
        
        // Create both links atomically using the new transaction-aware method
        var result = await commandDataService.CreateBidirectionalAsync(primaryLinkDto, reverseLinkDto);
        
        if (result.IsSuccess)
        {
            logger.LogInformation(
                "Created bidirectional link: {SourceId} -> {TargetId} ({LinkType})",
                sourceId, targetId, linkType);
        }
        
        return result;
    }
    
    /// <summary>
    /// Deletes a link and optionally its reverse link
    /// </summary>
    public async Task<ServiceResult<BooleanResultDto>> DeleteBidirectionalLinkAsync(
        ExerciseLinkId linkId, 
        bool deleteReverse)
    {
        // TRUST THE VALIDATION CHAIN! Validation has already been done
        return await ExecuteBidirectionalDeletionAsync(linkId, deleteReverse);
    }
    
    private async Task<ServiceResult<BooleanResultDto>> ExecuteBidirectionalDeletionAsync(
        ExerciseLinkId linkId,
        bool deleteReverse)
    {
        // Load the primary link for reverse link details
        var primaryLinkResult = await queryDataService.GetByIdAsync(linkId);
        
        // Delete the primary link
        var deleteResult = await commandDataService.DeleteAsync(linkId);
        
        // Handle deletion result using pattern matching
        return deleteResult switch
        {
            { IsSuccess: false } => deleteResult,
            { IsSuccess: true } when deleteReverse => await DeleteReverseLinkIfExistsAsync(primaryLinkResult.Data),
            _ => ServiceResult<BooleanResultDto>.Success(BooleanResultDto.Create(true))
        };
    }
    
    private async Task<ServiceResult<BooleanResultDto>> DeleteReverseLinkIfExistsAsync(ExerciseLinkDto primaryLink)
    {
        var reverseLinkResult = await FindReverseLinkAsync(primaryLink);
        
        // Delete reverse link if found
        var deletionTask = reverseLinkResult switch
        {
            { IsSuccess: true, Data: { IsEmpty: false } } => 
                commandDataService.DeleteAsync(ExerciseLinkId.ParseOrEmpty(reverseLinkResult.Data.Id)),
            _ => Task.FromResult(ServiceResult<BooleanResultDto>.Success(BooleanResultDto.Create(true)))
        };
        
        await deletionTask;
        
        if (reverseLinkResult.IsSuccess && !reverseLinkResult.Data.IsEmpty)
        {
            logger.LogInformation(
                "Deleted reverse link: {ReverseId}",
                reverseLinkResult.Data.Id);
        }
        
        return ServiceResult<BooleanResultDto>.Success(BooleanResultDto.Create(true));
    }
    
    private async Task<ServiceResult<ExerciseLinkDto>> FindReverseLinkAsync(ExerciseLinkDto originalLink)
    {
        // Parse all needed data upfront
        var originalLinkType = DetermineActualLinkType(originalLink);
        var reverseLinkType = GetReverseExerciseLinkType(originalLinkType);
        var targetId = ExerciseId.ParseOrEmpty(originalLink.TargetExerciseId);
        
        // Single exit point using pattern matching
        return reverseLinkType.HasValue switch
        {
            false => ServiceResult<ExerciseLinkDto>.Success(ExerciseLinkDto.Empty), // No reverse link expected
            true => await LoadAndFindReverseLinkAsync(targetId, reverseLinkType.Value, originalLink.SourceExerciseId)
        };
    }
    
    private async Task<ServiceResult<ExerciseLinkDto>> LoadAndFindReverseLinkAsync(
        ExerciseId targetId, 
        ExerciseLinkType reverseLinkType,
        string originalSourceId)
    {
        // Load reverse links from the target exercise
        var reverseLinksResult = await queryDataService.GetBySourceExerciseWithEnumAsync(targetId, reverseLinkType);
        
        // Find the specific reverse link using pattern matching
        var reverseLink = reverseLinksResult switch
        {
            { IsSuccess: true, Data: not null } => 
                reverseLinksResult.Data.FirstOrDefault(link => link.TargetExerciseId == originalSourceId),
            _ => null
        };
        
        // Return found link or Empty
        return ServiceResult<ExerciseLinkDto>.Success(reverseLink ?? ExerciseLinkDto.Empty);
    }
    
    /// <summary>
    /// Determines the actual link type from a DTO
    /// </summary>
    public static ExerciseLinkType DetermineActualLinkType(ExerciseLinkDto link)
    {
        // Use the ActualLinkType logic from the entity
        if (Enum.TryParse<ExerciseLinkType>(link.LinkType, out var enumValue))
        {
            return enumValue;
        }
        
        // Fallback for string-based links
        return link.LinkType switch
        {
            "Warmup" => ExerciseLinkType.WARMUP,
            "Cooldown" => ExerciseLinkType.COOLDOWN,
            _ => ExerciseLinkType.WARMUP // Default fallback
        };
    }
    
    /// <summary>
    /// Gets the reverse link type for bidirectional relationships
    /// </summary>
    public static ExerciseLinkType? GetReverseExerciseLinkType(ExerciseLinkType linkType)
    {
        // Based on the feature requirements, determine the reverse link type
        return linkType switch
        {
            ExerciseLinkType.WARMUP => ExerciseLinkType.WORKOUT,
            ExerciseLinkType.COOLDOWN => ExerciseLinkType.WORKOUT,
            ExerciseLinkType.ALTERNATIVE => ExerciseLinkType.ALTERNATIVE, // ALTERNATIVE is bidirectional with itself
            ExerciseLinkType.WORKOUT => null, // WORKOUT links are only created as reverse, never as primary
            _ => null
        };
    }
    
    private async Task<int> CalculateDisplayOrderAsync(
        ExerciseId source, 
        ExerciseLinkType linkType)
    {
        // Get existing links of same type for this source exercise
        var countResult = await queryDataService.GetLinkCountAsync(source, linkType.ToString());
        
        // Return next available display order (count + 1)
        return countResult.IsSuccess ? countResult.Data + 1 : 1;
    }
}