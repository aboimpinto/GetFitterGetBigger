using GetFitterGetBigger.API.DTOs;
using GetFitterGetBigger.API.Models.Enums;
using GetFitterGetBigger.API.Models.SpecializedIds;
using GetFitterGetBigger.API.Services.Exercise.Features.Links.DataServices;
using GetFitterGetBigger.API.Services.Results;

namespace GetFitterGetBigger.API.Services.Exercise.Features.Links.Handlers;

/// <summary>
/// Handles bidirectional link creation and deletion for exercise links
/// </summary>
public class BidirectionalLinkHandler(
    IExerciseLinkQueryDataService queryDataService,
    IExerciseLinkCommandDataService commandDataService,
    ILogger<BidirectionalLinkHandler> logger) : IBidirectionalLinkHandler
{
    /// <summary>
    /// Creates bidirectional links between exercises
    /// </summary>
    public async Task<ServiceResult<ExerciseLinkDto>> CreateBidirectionalLinkAsync(
        ExerciseId sourceId,
        ExerciseId targetId,
        ExerciseLinkType linkType)
    {
        // Get the reverse link type based on the mapping rules
        var reverseLinkType = GetReverseExerciseLinkType(linkType);
        
        // Calculate display orders for both links
        var primaryDisplayOrder = await CalculateDisplayOrderAsync(sourceId, linkType);
        
        // Create the primary link DTO
        var primaryLinkDto = new ExerciseLinkDto
        {
            Id = string.Empty, // Will be generated by the database
            SourceExerciseId = sourceId.ToString(),
            TargetExerciseId = targetId.ToString(),
            LinkType = linkType.ToString(),
            DisplayOrder = primaryDisplayOrder,
            IsActive = true
        };
        
        // Create the reverse link DTO if needed
        ExerciseLinkDto? reverseLinkDto = null;
        if (reverseLinkType.HasValue)
        {
            var reverseDisplayOrder = await CalculateDisplayOrderAsync(targetId, reverseLinkType.Value);
            reverseLinkDto = new ExerciseLinkDto
            {
                Id = string.Empty, // Will be generated by the database
                SourceExerciseId = targetId.ToString(),
                TargetExerciseId = sourceId.ToString(),
                LinkType = reverseLinkType.Value.ToString(),
                DisplayOrder = reverseDisplayOrder,
                IsActive = true
            };
        }
        
        // Create both links atomically using the new transaction-aware method
        var result = await commandDataService.CreateBidirectionalAsync(primaryLinkDto, reverseLinkDto);
        
        if (result.IsSuccess)
        {
            logger.LogInformation(
                "Created bidirectional link: {SourceId} -> {TargetId} ({LinkType})",
                sourceId, targetId, linkType);
        }
        
        return result;
    }
    
    /// <summary>
    /// Deletes a link and optionally its reverse link
    /// </summary>
    public async Task<ServiceResult<BooleanResultDto>> DeleteBidirectionalLinkAsync(
        ExerciseLinkId linkId, 
        bool deleteReverse)
    {
        // TRUST THE VALIDATION CHAIN! Validation has already been done
        return await ExecuteBidirectionalDeletionAsync(linkId, deleteReverse);
    }
    
    private async Task<ServiceResult<BooleanResultDto>> ExecuteBidirectionalDeletionAsync(
        ExerciseLinkId linkId,
        bool deleteReverse)
    {
        // Load the primary link for reverse link details
        var primaryLinkResult = await queryDataService.GetByIdAsync(linkId);
        
        // Delete the primary link
        var deleteResult = await commandDataService.DeleteAsync(linkId);
        
        // Handle deletion result using pattern matching
        return deleteResult switch
        {
            { IsSuccess: false } => deleteResult,
            { IsSuccess: true } when deleteReverse => await DeleteReverseLinkIfExistsAsync(primaryLinkResult.Data),
            _ => ServiceResult<BooleanResultDto>.Success(BooleanResultDto.Create(true))
        };
    }
    
    private async Task<ServiceResult<BooleanResultDto>> DeleteReverseLinkIfExistsAsync(ExerciseLinkDto primaryLink)
    {
        var reverseLinkResult = await FindReverseLinkAsync(primaryLink);
        
        // Use extension method for clean deletion with logging pushed down
        return await commandDataService.DeleteIfExistsAsync(reverseLinkResult, logger);
    }
    
    private async Task<ServiceResult<ExerciseLinkDto>> FindReverseLinkAsync(ExerciseLinkDto originalLink)
    {
        // Parse all needed data upfront
        var originalLinkType = DetermineActualLinkType(originalLink);
        var targetId = ExerciseId.ParseOrEmpty(originalLink.TargetExerciseId);
        var sourceId = originalLink.SourceExerciseId;
        
        // Special handling for WORKOUT links - they are reverse links from WARMUP/COOLDOWN
        // We need to find what type of link points back to us
        if (originalLinkType == ExerciseLinkType.WORKOUT)
        {
            return await FindReverseWorkoutLinkAsync(targetId, sourceId);
        }
        
        var reverseLinkType = GetReverseExerciseLinkType(originalLinkType);
        
        // Single exit point using pattern matching
        return reverseLinkType.HasValue switch
        {
            false => ServiceResult<ExerciseLinkDto>.Success(ExerciseLinkDto.Empty), // No reverse link expected
            true => await LoadAndFindReverseLinkAsync(targetId, reverseLinkType.Value, sourceId)
        };
    }
    
    private async Task<ServiceResult<ExerciseLinkDto>> LoadAndFindReverseLinkAsync(
        ExerciseId targetId, 
        ExerciseLinkType reverseLinkType,
        string originalSourceId)
    {
        // Load reverse links from the target exercise
        var reverseLinksResult = await queryDataService.GetBySourceExerciseWithEnumAsync(targetId, reverseLinkType);
        
        // Find the specific reverse link using pattern matching
        var reverseLink = reverseLinksResult switch
        {
            { IsSuccess: true, Data: not null } => 
                reverseLinksResult.Data.FirstOrDefault(link => link.TargetExerciseId == originalSourceId),
            _ => null
        };
        
        // Return found link or Empty
        return ServiceResult<ExerciseLinkDto>.Success(reverseLink ?? ExerciseLinkDto.Empty);
    }
    
    /// <summary>
    /// Special handler for finding reverse links when deleting WORKOUT type links.
    /// WORKOUT links are created as reverse links from WARMUP/COOLDOWN, so we need to find which one.
    /// </summary>
    private async Task<ServiceResult<ExerciseLinkDto>> FindReverseWorkoutLinkAsync(
        ExerciseId workoutExerciseId, 
        string originalSourceId)
    {
        // Use extension methods for clean, single-exit-point pattern
        var reverseLink = await queryDataService.FindFirstMatchingReverseLinkAsync(
            workoutExerciseId,
            ExerciseLinkType.WORKOUT.GetPossibleReverseTypes(),
            originalSourceId,
            logger);
        
        return reverseLink.ToServiceResult();
    }
    
    /// <summary>
    /// Determines the actual link type from a DTO
    /// </summary>
    public static ExerciseLinkType DetermineActualLinkType(ExerciseLinkDto link)
    {
        // Use the ActualLinkType logic from the entity
        if (Enum.TryParse<ExerciseLinkType>(link.LinkType, out var enumValue))
        {
            return enumValue;
        }
        
        // Fallback for string-based links
        return link.LinkType switch
        {
            "Warmup" => ExerciseLinkType.WARMUP,
            "Cooldown" => ExerciseLinkType.COOLDOWN,
            _ => ExerciseLinkType.WARMUP // Default fallback
        };
    }
    
    /// <summary>
    /// Gets the reverse link type for bidirectional relationships during creation.
    /// Note: For deletion of WORKOUT links, special handling is required (see FindReverseWorkoutLinkAsync).
    /// </summary>
    public static ExerciseLinkType? GetReverseExerciseLinkType(ExerciseLinkType linkType)
    {
        // Based on the feature requirements, determine the reverse link type
        return linkType switch
        {
            ExerciseLinkType.WARMUP => ExerciseLinkType.WORKOUT,
            ExerciseLinkType.COOLDOWN => ExerciseLinkType.WORKOUT,
            ExerciseLinkType.ALTERNATIVE => ExerciseLinkType.ALTERNATIVE, // ALTERNATIVE is bidirectional with itself
            ExerciseLinkType.WORKOUT => null, // WORKOUT links are created as reverse links from WARMUP/COOLDOWN
                                               // For deletion, use FindReverseWorkoutLinkAsync to find the actual reverse
            _ => null
        };
    }
    
    private async Task<int> CalculateDisplayOrderAsync(
        ExerciseId source, 
        ExerciseLinkType linkType)
    {
        // Get existing links of same type for this source exercise
        var countResult = await queryDataService.GetLinkCountAsync(source, linkType.ToString());
        
        // Return next available display order (count + 1)
        return countResult.IsSuccess ? countResult.Data + 1 : 1;
    }
}